---
title: "[Java] Java 8 에서 자주 만나는 것들 2"
excerpt: "Lambda, Stream, Optional"

categories:
  - Development
tags:
  - java
header:
  teaser: /assets/images/dev/java.png
---

<small>참조 : <a href="http://tcpschool.com/java/java_stream_concept">http://tcpschool.com/java/java_stream_concept</a></small><br>
<small>참조 : <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html">https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html</small>

## Stream

Java에서 배열이나 컬렉션을 사용하는 경우가 많은데, 요소에 접근할 때 반복문이나 반복자(iterator)를 사용한다. 이는 코드를 길어지게 하고, 가독성이 떨어지고, 재사용이 거의 불가능하다.

따라서 Java 8 부터는 **Stream API**를 도입한다. Stream은 다음과 같은 특징을 가진다.

### Stream의 특징

| No storage. A stream is not a data structure that stores elements; instead, it conveys elements from a source such as a data structure, an array, a generator function, or an I/O channel, through a pipeline of computational operations.

Stream은 요소를 저장하지 않는 대신 전달한다. 연산 pipeline을 통해서.

| Functional in nature. An operation on a stream produces a result, but does not modify its source. For example, filtering a Stream obtained from a collection produces a new Stream without the filtered elements, rather than removing elements from the source collection.

원본 데이터를 수정하지 않는다.

| Laziness-seeking. Many stream operations, such as filtering, mapping, or duplicate removal, can be implemented lazily, exposing opportunities for optimization. For example, "find the first String with three consecutive vowels" need not examine all the input strings. Stream operations are divided into intermediate (Stream-producing) operations and terminal (value- or side-effect-producing) operations. Intermediate operations are always lazy.

게으름을 피운다. 가 아니고, 지연(lazy) 연산을 통해 성능을 최적화한다. 예를 들어 "3개 연속 모음(a, i, u, e, o)이 있는 문자열 찾기"에서 모든 문자열을 검사할 필요가 없다. Stream은 중개 연산과 최종 연산이 있는데, 중개 연산은 항상 게으르다.

| Possibly unbounded. While collections have a finite size, streams need not. Short-circuiting operations such as limit(n) or findFirst() can allow computations on infinite streams to complete in finite time.

무한할 수 있다. 무한 스트림은 `limit(n)` 또는 `findFirst()`로 유한한 시간에 끝낼 수 있다.

| Consumable. The elements of a stream are only visited once during the life of a stream. Like an Iterator, a new stream must be generated to revisit the same elements of the source.

스트림은 1회용이다. 재사용할 수 없다.

## Stream 생성

Stream의 생성 방법이 다양한데 예제와 함께 알아보자.

### `Collections` 인터페이스의 `stream()` 메소드

```java
private static void streamPractice1() {
  ArrayList<Integer> list = new ArrayList<>();

  list.add(4);
  list.add(2);
  list.add(3);
  list.add(1);

  Stream<Integer> stream = list.stream();
  stream.map(i -> i + " ").forEach(System.out::print);
}
```

```text
4 2 3 1
```

`stream()`메소드는 `Collection` 인터페이스에 있는 메소드로 `ArrayList`, `HashSet` 등을 Stream으로 만들 수 있다.

그 외에 `map()`이나 `forEach()`는 뒤에서 다룰 것이다.

### `Arrays` 클래스의 `stream()` 메소드

```java
private static void streamPractice2() {
  String[] arr = new String[] {"넷", "둘", "셋", "하나"};

  Stream<String> stream = Arrays.stream(arr);
  stream.forEach(e -> System.out.print(e + " "));
  System.out.println();

  Arrays.stream(arr, 1, 3).forEach(e -> System.out.print(e + " "));
}
```

```text
딸기 당근 수박 참외 메론
당근 수박
```

배열에 대해서는 `Arrays` 클래스의 `stream()` 메소드를 사용하며, 또한 특정 부분만을 Stream으로 생성할 수 있다.

### `Stream` 클래스의 `of()` 메소드

```java
private static void streamPractice3() {
  Stream<Double> stream1 = Stream.of(3.14, 1.57, 2.0, 5.55555, 3.11);
  stream1.map(d -> d + " ").forEach(System.out::print);

  System.out.println();

  Stream<Integer> stream2 = Stream.of(100, 200);
  stream2.map(d -> d + " ").forEach(System.out::print);
}
```

```text
3.14 1.57 2.0 5.55555 3.11
100 200
```

`Stream` 클래스의 `of()` 메소드를 사용하여 가변 매개변수를 사용할 수도 있다.

### `IntStream` 인터페이스의 `range()` 메소드

```java
private static void streamPractice4() {
  IntStream stream1 = IntStream.range(1, 5);
  stream1.forEach(System.out::print);
}
```

```text
1234
```

python 반복문 배울 때 신박하다고 생각했던 range를 여기서 다시 보게 되니 반갑다. 지정된 범위의 연속된 정수를 스트림으로 생성하기 위해서 `IntStream` 인터페이스의 `range()` 메소드를 사용할 수 있다.

다른 인터페이스로 `LongStream`도 있으며, `rangeClosed()` 메소드도 있다. `rangeClosed()`는 이름에서도 알 수 있듯이 `range()`에서 두 번째 매개변수를 제외한다면 `rangeClosed()`는 포함한다.

### `Random` 클래스의 `ints()` 메소드

```java
private static void streamPractice5() {
  IntStream stream = new Random().ints(4);
  stream.forEach(System.out::println);
}
```

```text
2058464775
-328584945
-326803370
817906855
```

`Random` 클래스에는 `ints()` 메소드 뿐 아니라 `longs()`, `doubles()`와 같은 메소드도 있다. 이 메소드들의 매개변수는 개수를 의미하며, 이게 없으면 무한 스트림(infinite stream)을 생성한다. 무한 스트림은 `limit()` 메소드를 사용하여 개수를 제한할 수 있다.

### `Stream` 클래스의 `iterate()` 메소드

```java
private static void streamPractice6() {
  Stream<Integer> stream1 = Stream.iterate(2, n -> n+2);
  stream1.limit(5).forEach((i) -> System.out.print(i + " "));

  System.out.println();

  Stream<Integer> stream2 = Stream.generate(() -> 5);
  stream2.limit(5).forEach((i) -> System.out.print(i + " "));
}
```

```text
2 4 6 8 10
5 5 5 5 5
```

`iterate()` 메소드는 람다 표현식을 사용하여, 반환된 값을 다시 사용하는 방식으로 무한 스트림을 생성한다.

`generate()` 메소드는 매개변수를 받지 않는 람다 표현식을 사용하여, 반환된 값으로 무한 스트림을 생성한다.

## Stream 중개 연산

스트림을 또 다른 스트림으로 변환할 수 있다. 여러 개 연결해서 사용할 수도 있다. 팰터-맵(filter-map) 기반의 API를 사용함으로써 **지연(lazy) 연산을 통해 성능을 최적화**할 수 있다.

1. 필터링 : `filter()`, `distinct()`
2. 변환 : `map()`, `flatMap()`
3. 제한 : `limit()`, `skip()`
4. 정렬 : `sort()`
5. 연산 결과 확인 : `peek()`

### 필터링

```java
private static void streamPractice7() {
  IntStream stream1 = IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6);
  IntStream stream2 = IntStream.of(7, 5, 5, 2, 1, 2, 3, 5, 4, 6);

  stream1.distinct().forEach(e -> System.out.print(e + " "));
  System.out.println();

  stream2.filter(n -> n%2 != 0).forEach(e -> System.out.print(e + " "));
}
```

```text
7 5 2 1 3 4 6 
7 5 5 1 3 5 
```

`distinct()` 메소드는 중복을 제거한다. `filter()` 메소드는 조건을 정의하여 조건을 만족하는 요소만 통과시킨다. 예제의 `filter()` 메소드 내부에는 람다 표현식을 사용하는 것처럼, `boolean`형을 리턴하는 함수를 정의한다.

### 변환

```java
private static void streamPractice8() {
  Stream<String> stream = Stream.of("HTML", "CSS", "JAVA", "JAVASCRIPT");
  stream.map(String::length).forEach(e -> System.out.print(e + " "));
}
```

```text
4 3 4 10 
```

`map()` 메소드는 각 요소에 대한 로직을 작성할 수 있다. 예제 에서는 간단하게 문자열의 길이를 리턴하게 했지만 반복문 대신 스트림을 사용한다면 `map()` 메소드를 가장 많이 사용하게 되지 않을까 싶다. 내부 로직이 길어진다면 보기 안 좋으니 함수로 빼는 것이 좋겠다.

```java
private static void streamPractice8() {
  String[] arr = {"Hello", "World", "Happy", "Meet", "Develop"};
  Arrays.stream(arr)
          .flatMap(str -> Stream.of(str.split("")))
          .forEach(c -> System.out.print(c + " "));
}
```

```text
H e l l o W o r l d H a p p y M e e t D e v e l o p 
```

`flatMap()` 메소드는 요소가 배열이라면 그걸 풀어헤치는 역할을 합니다. 예제에서 문자열을 `split()` 메소드를 통해 문자들이 하나하나 분열된 스트림을 만들었고 이를 `flatMap()` 메소드가 하나의 스트림으로 만듭니다.

### 제한

```java
private static void streamPractice10() {
  IntStream stream1 = IntStream.range(0, 10);
  IntStream stream2 = IntStream.range(0, 10);
  IntStream stream3 = IntStream.range(0, 10);

  stream1.skip(4).forEach(n -> System.out.print(n + " "));
  System.out.println();

  stream2.limit(5).forEach(n -> System.out.print(n + " "));
  System.out.println();

  stream3.skip(3).limit(5).forEach(n -> System.out.print(n + " "));
}
```

```text
4 5 6 7 8 9 
0 1 2 3 4 
3 4 5 6 7 
```

`skip()` 메소드는 첫 번째부터 전달받은 개수만큼 건너뛴 스트림을 만든다. `limit()` 메소드는 첫 번째 부터 전달받은 개수만큼만으로 이루어진 스트림을 만든다.

### 정렬

```java
private static void streamPractice11() {
  Stream<String> stream1 = Stream.of("Apple", "Zebra", "Banana", "Cup");
  Stream<String> stream2 = Stream.of("Apple", "Zebra", "Banana", "Cup");

  stream1.sorted().forEach(s -> System.out.print(s + " "));
  System.out.println();

  stream2.sorted(Comparator.reverseOrder()).forEach(s -> System.out.print(s + " "));
}
```

```text
Apple Banana Cup Zebra 
Zebra Cup Banana Apple 
```

`sorted()` 메소드는 해당 스트림을 정렬한다. `Comparator` 인터페이스를 이용하여 정렬할 수도 있다.

### 결과 확인

```java
private static void streamPractice12() {
  Stream<String> stream = Stream.of("A", "B", "C", "D", "E", "F", "G");

  stream.peek(s -> System.out.println("원본 : " + s))
          .skip(2)
          .peek(s -> System.out.println("skip(2) 후 : " + s))
          .limit(3)
          .peek(s -> System.out.println("limit(3) 후 : " + s))
          .sorted(Collections.reverseOrder())
          .peek(s -> System.out.println("sorted() 후 : " + s))
          .forEach(System.out::println);
}
```

```text
원본 : A
원본 : B
원본 : C
skip(2) 후 : C
limit(3) 후 : C
원본 : D
skip(2) 후 : D
limit(3) 후 : D
원본 : E
skip(2) 후 : E
limit(3) 후 : E
sorted() 후 : E
E
sorted() 후 : D
D
sorted() 후 : C
C
```

`peek()` 메소드는 **스트림의 연산과 연산 사이에 결과를 확인(디버깅)할 때 주로 사용**한다. 처음에 저 아웃풋이 무엇을 의미하는 건지 이해하기 힘들었다. 연산별로 보면 각 연산 이후의 스트림이 뭐가 되는지 알 수 있었다. 근데 이걸 매 연산 사이마다 `peek()` 메소드를 실행하니 복잡했다.

저 복잡한 흐름을 자세히 보니 신기한 점이 있다. `skip()`과 `limit()`은 스트림의 요소별로, 그러니까 `"A"` 따로 `"B"` 따로 이렇게 지나가는 듯 했다. `sorted()`는 요소를 쌓아두었다가 정렬하고 통과시키는 느낌이었다.(당연히 정렬하려면 그래야 겠지만) 이와 관련해서 Oracle Java 문서에서 아래의 글을 발견했다.

| Intermediate operations are further divided into stateless and stateful operations. Stateless operations, such as filter and map, retain no state from previously seen element when processing a new element -- each element can be processed independently of operations on other elements. Stateful operations, such as distinct and sorted, may incorporate state from previously seen elements when processing new elements. 

**중개연산은 stateless와 stateful로 나뉘어진다.** stateless는 filter와 map이 있다. 이것들은 새 요소를 처리할 때 이전 요소의 상태를 유지할 필요 없다. 각 요소들은 독립적으로 처리된다. stateful 연산은 distinct와 sorted가 있다. 이것들은 새 요소를 처리할 때 이전 요소의 상태가 필요할 수 있다.

| Stateful operations may need to process the entire input before producing a result. For example, one cannot produce any results from sorting a stream until one has seen all elements of the stream. As a result, under parallel computation, some pipelines containing stateful intermediate operations may require multiple passes on the data or may need to buffer significant data. Pipelines containing exclusively stateless intermediate operations can be processed in a single pass, whether sequential or parallel, with minimal data buffering.

**stateful 연산은 결과를 생성하기 전에 전체 입력을 처리해야 한다.** 예를 들어, 모든 요소를 보기 전까지 정렬 결과를 얻을 수 없다. 그 결과, 병렬 연산을 하려면 중요한 데이터에 대한 multiple pass 또는 buffer가 필요하다. stateless 연산만 있는 pipeline은 순차적이든 병렬적이든 single pass로 처리할 수 있다.

그러니까, `sorted()`는 stateful 연산이니 모든 요소를 기다린다는 것이다. 그러면 `peek()`을 통해서 확인한 결과가 설명된다.

여기서 생기는 다른 의문은 `sorted()`는 모든 요소를 기다리는 stateful 중개 연산인데, 어디가 lazy하다는 것일까. 문서에 따르면 모든 중개연산은 lazy하다고 나와있는데, 이거랑 모순이 아닌가 하는 생각이 든다.

## Stream의 최종 연산

